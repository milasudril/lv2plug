#!/usr/bin/env php
<?php
function exception_error_handler($errno, $errstr, $errfile, $errline ) {
    throw new ErrorException($errstr, $errno, 0, $errfile, $errline);
}
set_error_handler("exception_error_handler");
try
{
$output_buffer='';
function ob_file_callback($buffer)
	{
	global $output_buffer;
	$output_buffer.=$buffer;
	}
ob_start('ob_file_callback');

function CamelCase(string $str)
	{
//TODO: Use preg_split instead...
	$x=explode(' ',$str);
	foreach($x as &$namepart)
		{$namepart=ucfirst($namepart);}
	return implode('',$x);
	}

function guardname(string $scope,string $filename)
	{
//TODO: Use preg_split instead...
	$x=[$scope];
	$x=array_merge($x,explode('.',$filename));
	foreach($x as &$namepart)
		{$namepart=strtoupper($namepart);}
	return implode('_',$x);
	}

function cxxconstant(string $name)
	{
//TODO: Use preg_split instead...
	$x=explode(' ',$name);
	foreach($x as &$namepart)
		{$namepart=strtoupper($namepart);}
	return implode('_',$x);
	}

function typeGet($port)
	{
	$ret='';
	if($port->{'direction'}=='in')
		{$ret.='const ';}
	$typemap=array('midi'=>'LV2_Atom_Sequence*'
		,'audio'=>'float*'
		,'control'=>'float');
	$ret.=$typemap[$port->{'type'}];
	return $ret;
	}

if($argc<2)
	{
	error_log('No input file is specified');
	exit(-1);
	}

if($argc<3)
	{
	error_log('No target directory is specified');
	exit(-1);
	}
$content=json_decode(file_get_contents($argv[1]));
$plugindata=$content->{'specification'};
$name=$plugindata->{'name'};
$namespace=CamelCase($name);
$guard=guardname($namespace,$content->{'targets'}[0]->{'name'});
?>
// This file has been generated by <?=$argv[0]?>

#ifndef <?=$guard?>

#define <?=$guard?>

#include <lv2/lv2plug.in/ns/ext/atom/atom.h>
#include <lv2/lv2plug.in/ns/ext/atom/util.h>

namespace <?=$namespace?>

	{
	struct PluginDescriptor
		{
<?php foreach($plugindata as $field => $value)
	{
	if(!is_array($value) && !is_object($value))
		{
		$constant=cxxconstant($field);?>
		static constexpr const char* <?=$constant?>="<?=$value?>";
		static constexpr const char* <?=strtolower($constant)?>Get() noexcept
			{return <?=cxxconstant($field)?>;}

<?php	}
	}
if(isset($plugindata->{'ui'})) {?>
		static constexpr const char* UI_URI="<?=$plugindata->{'ui'}->{'uri'} ?>";
		static constexpr const char* uiUriGet() noexcept
			{return UI_URI;}
<?php }?>

		struct Ports
			{
<?php foreach($plugindata->{'ports'} as $index=>$port) {?>
			static constexpr unsigned int <?=cxxconstant($port->{'name'})?>=<?=$index ?>;
<?php }?>

			static constexpr unsigned int PORT_COUNT=<?=count($plugindata->{'ports'}) ?>;

			template<unsigned int port_id>
			struct TypeGet
				{typedef void type;};

			static constexpr const char* PORTNAMES[]={<?php foreach($plugindata->{'ports'} as $index=>$port)
	{
	echo '"'.$port->{'name'}.'",';
	}?>nullptr};
			};
		};

<?php foreach($plugindata->{'ports'} as $index=>$port) {?>
	template<>
	struct PluginDescriptor::Ports::TypeGet<PluginDescriptor::Ports::<?=cxxconstant($port->{'name'})?>>
			{typedef <?=typeGet($port)?> type;};

<?php }?>
	}
#endif
<?php 
$ob_file=fopen($argv[2].'/'.$content->{'targets'}[0]->{'name'},'w','w');
ob_flush();
fwrite($ob_file,$output_buffer);
}
catch(Exception $e)
{
error_log($e->getMessage());
}
?>