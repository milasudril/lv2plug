// This file has been generated by ../lv2spectohpp.php
#ifndef MONOPHONICSYNTH_TEST_HPP
#define MONOPHONICSYNTH_TEST_HPP
#include <lv2/lv2plug.in/ns/ext/atom/atom.h>
#include <lv2/lv2plug.in/ns/ext/atom/util.h>

namespace MonophonicSynth
	{
	constexpr const char* NAME="Monophonic synth";
	constexpr const char* URI="http://example.org/monosynth";
	constexpr const char* BINARY="monosynth.so";
	constexpr const char* MAINTAINER="Torbj√∂rn Rathsman";
	constexpr const char* LICENSE="https://opensource.org/licenses/isc";
	constexpr const char* TYPE="InstrumentPlugin";
	constexpr unsigned int PORT_COUNT=3;

	namespace Ports
		{
		constexpr unsigned int MIDI_IN=0;
		constexpr unsigned int CUTOFF=1;
		constexpr unsigned int AUDIO_OUT=2;

		template<unsigned int port_id>
		struct TypeGet
			{typedef void type;};

		template<>
		struct TypeGet<MIDI_IN>
			{typedef const LV2_Atom_Sequence* type;};

		template<>
		struct TypeGet<CUTOFF>
			{typedef const float* type;};

		template<>
		struct TypeGet<AUDIO_OUT>
			{typedef float* type;};

		constexpr const char* PORTNAMES[]={"MIDI in","Cutoff","Audio out",nullptr};
		}

	class PortMap
		{
		public:
			template<unsigned int port_id>
			auto get() noexcept
				{
				static_assert(port_id < PORT_COUNT,"Bad port number");
				return reinterpret_cast<typename Ports::TypeGet<port_id>::type>(ports[port_id]);
				}

			PortMap& connect(unsigned int port_index,void* buffer) noexcept
				{
				ports[port_index]=buffer;
				return *this;
				}

		private:
			void* ports[PORT_COUNT];
		};
	};
#endif
